#version 450
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"

layout (local_size_x = 256) in;

// constants for the culling process
layout(set = 0, binding = 0) uniform CullingSettingsUBO
	{   
	mat4 viewTransform; // view transform
	vec3 viewPosition; // origin of the view in world space
	float frustumXx; // frustum culling data X.x
	float frustumXz; // frustum culling data X.z
	float frustumYy; // frustum culling data Y.y
	float frustumYz; // frustum culling data Y.z
	float nearZ; // near depth
	float farZ; // far depth

	// pyramid culling info
	bool pyramidCull; // is set, use depth pyramid to cull
	float Proj00; // projection[0][0]
	float Proj11; // projection[1][1]
	float pyramidWidth; // width of the largest mip in the depth pyramid
	float pyramidHeight; // height of the largest mip in the depth pyramid

	// number of objects to consider in the renderObjectBuffer buffer
	uint objectsCount; 

	// values that are only for debugging purposes
	float debug_float_value1; 
	float debug_float_value2; 
	float debug_float_value3; 
	} cullingSettings;

// the input buffer of objects to consider for rendering. the size is defined in the "objectsCount" constant. Indexed with renderIndex.
layout(set = 0, binding = 1) readonly buffer RenderObjectsBuffer
	{   
	uint objectIDs[];
	} renderObjectsBuffer;

// buffer containing information on all objects in the scene. Indexed with objectID.
layout(set = 0, binding = 2) readonly buffer SceneObjectsBuffer 
	{ 
	SceneObject objects[]; 
	} sceneObjectsBuffer;

// the DrawCommand buffer, one command for every possible batch. Indexed with batchID
layout(set = 0, binding = 3)  buffer FilteredDrawBuffer
	{   
	DrawCommand commands[];
	} filteredDrawBuffer;

// per-instance information
layout(set = 0, binding = 4)  buffer InstanceBuffer
	{   
	Instance instances[];
	} instanceBuffer;

// depth pyramid to read depth from 
layout(set = 0, binding = 5) uniform sampler2D depthPyramidSampler;

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
vec4 projectSphere(vec3 C, float r )
	{
	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;
	
	vec4 aabb = vec4(
			minx.x / minx.y * cullingSettings.Proj00, 
			miny.x / miny.y * cullingSettings.Proj11, 
			maxx.x / maxx.y * cullingSettings.Proj00, 
			maxy.x / maxy.y * cullingSettings.Proj11
			);

	if( isnan(aabb.x) || isnan(aabb.y) ||  isnan(aabb.z) ||  isnan(aabb.w) )
		{
		return vec4(0,0,1,1);
		}

	// clip space -> uv sample space, also flip because of right hand coords
	aabb = (aabb.zyxw * -0.5f) + vec4(0.5f); 
	return aabb;
	}

void main() 
	{		
	// get the index in the renderObjectBuffer
	uint renderIndex = gl_GlobalInvocationID.x;
	if( renderIndex < cullingSettings.objectsCount )
		{
		// get the object, check if it is visible
		uint objectID = renderObjectsBuffer.objectIDs[renderIndex];

		// grab sphere cull data from the object buffer
		vec4 boundingSphere = sceneObjectsBuffer.objects[objectID].boundingSphere;

		// transform the bounds into view space
		vec3 center = boundingSphere.xyz;
		center = (cullingSettings.viewTransform * vec4(center,1.f)).xyz;
		float radius = boundingSphere.w;
	
		// get the direction in world space to the object
		vec3 object_direction = normalize(sceneObjectsBuffer.objects[objectID].rejectionConeCenter - cullingSettings.viewPosition);
		vec3 object_rejection_direction = sceneObjectsBuffer.objects[objectID].rejectionConeDirectionAndCutoff.xyz;
		float object_rejection_cutoff = sceneObjectsBuffer.objects[objectID].rejectionConeDirectionAndCutoff.w;

		// assume visible
		bool isVisible = true;
	
		// frustrum culling using frustum data and depth values
		// use mirror symmetry of x&y to test both sides at the same time by using abs value 
		isVisible = isVisible && center.z * cullingSettings.frustumXz - abs(center.x) * cullingSettings.frustumXx > -radius; // +-x planes
		isVisible = isVisible && center.z * cullingSettings.frustumYz - abs(center.y) * cullingSettings.frustumYy > -radius; // +-y planes
		isVisible = isVisible && center.z - radius < -cullingSettings.nearZ && center.z + radius > -cullingSettings.farZ; // depth
		isVisible = isVisible && dot(object_direction,object_rejection_direction) > object_rejection_cutoff;

		uint quantization_level = 0;

		// project the object on-screen, calculate the quantization level and optionally check if the object is hidden
		if( isVisible )
			{
			vec4 aabb = projectSphere( center, radius );
			float width = (aabb.z - aabb.x) * cullingSettings.pyramidWidth;
			float height = (aabb.w - aabb.y) * cullingSettings.pyramidHeight;
			float pyramid_level = floor(log2(max(width, height)));

			quantization_level = clamp(12-uint(pyramid_level),0,16);

			// occlusion culling
			if( cullingSettings.pyramidCull ) 
				{
				float sampleDepth = textureLod(depthPyramidSampler, (aabb.xy + aabb.zw)/2, pyramid_level).x;

				// calc the depths to compare
				float near = cullingSettings.nearZ;
				float far = cullingSettings.farZ;
				sampleDepth = -(2.0 * near * far) / (far + near - sampleDepth * (far - near));
				float sphereDepth = center.z + radius;
		
				isVisible = sphereDepth > sampleDepth;
				}
			}

		// if the object is visible, add it to the render batch, and retrieve an instanceID 
		if( isVisible )
			{
			// find the lod level
			uint lodlevel = 0;
			while( lodlevel < 3 )
				{
				if( sceneObjectsBuffer.objects[objectID].LODQuantizations[lodlevel+1] > quantization_level )
					{
					break;
					}
				++lodlevel;
				}

			// retrieve the batchID from the scene object
			uint batchID = sceneObjectsBuffer.objects[objectID].batchID + lodlevel;

			// increase instance count and retrieve instanceID
			uint instanceIndex = atomicAdd(filteredDrawBuffer.commands[batchID].instanceCount,1);
			instanceIndex += filteredDrawBuffer.commands[batchID].firstInstance;

			// fill in the instance information
			instanceBuffer.instances[instanceIndex].objectID = objectID;
			instanceBuffer.instances[instanceIndex].quantizationMask = 0xffffffff << quantization_level; 
			instanceBuffer.instances[instanceIndex].quantizationRound = (1 << quantization_level) >> 1; 
			}
		}
	}
